# EPG Java Challenge

### Description

Software to generate a monthly billing relative to a Payment Processor and an Ecommerce platform linked to.

Built using Spring Boot + Spring Data JPA, using H2 as an embedded in-memory database. Unit testing is implemented using JUnit + Mockito and Springfox is used to generate Swagger API reference.

The application exposes a REST API and uses a Controller -> Service -> Repository architecture.

### How to use

To run, execute "mvn spring-boot:run" from the CLI.
This will make the API accesible from http://localhost:8080

The database exists only while the application runs, and all data is lost when it stops.
For convenience, the DB is automatically created in each execution with script src/main/resources/schema.sql and populated with some test data with script src/main/resources/data.sql.
A database web client is enabled at http://localhost:8080/h2 (use default credentials to login) and from there data can be inspected, added, modified, etc, by using the integrated SQL editor.

Data can also be added using the REST API:

* PUT http://localhost:8080/api/PaymentProcessors adds/updates a PaymentProcessor
* GET http://localhost:8080/api/PaymentProcessors/{id} retrieves a single PaymentProcessor
* GET http://localhost:8080/api/PaymentProcessors retrieves all PaymentProcessors

* PUT http://localhost:8080/api/ECommerces/{id} adds/update an ECommerce
* GET http://localhost:8080/api/ECommerces retrieves all ECommerces

* PUT http://localhost:8080/api/PaymentProcessors/{id}/ProcessPaymentFrom/{eCommerceId}/Amount/{amount} Processes a payment made by ECommerce {eCommerceId} of amount {amount} by PaymentProcessor {id}

And the billings and settlements can be obtained with the following API calls:

* GET http://localhost:8080/api/PaymentProcessors/{id}/Billing/{year}/{month} Obtains the billing for PaymentProcessor {id} for date {year}/{month}

* GET http://localhost:8080/api/ECommerces/{id}/SettlementFor/{paymentProcessorId}/{year}/{month} Obtains the settlement from Ecommerce {id} for PaymentProcessor {paymentProcessorId} for date {year}/{month}

Currently there is no support for deleting data from the API, it will have to be done either from the database web client or by rebooting the application.

There is Swagger documentation for this API available from http://localhost:8080/swagger-ui/, where the API can also be used and tested. If not, other tools of your choice such as Postman or SoapUI can be used.

### Considerations regarding requirements

After discussing some questions about the requirements, the following interpretations were made:

REQUIREMENT 2:
For APPs specified like the example below:
>Volume: 100/day - APP: 2%
>Volume: 200/day - APP: 1%

From 1-100 transactions APP would be 2%
From 101-200 transactions APP would be 1%
Above 200 transactions APP would still be 1%

Billing will be calculated taking applying the average daily number of transactions (transactions in month / days in month). For the example above, for 30000 transactions the average daily volume would be 100/day and the APP of 2% would be applied to all transactions in that month, even if some of the days had more than 100 transactions/day.

REQUIREMENT 4:
A settlement will be generated by an ECommerce for a given PaymentProcessor, year and month and the transactions will be grouped depending on their amount. For example: 10000 payments of amount 5€, 20000 payment of amount 3€

REQUIREMENT 5:
Since billing is done monthly, a year and month have to be specified even if this is not mentioned in the requirement. 
Also the billing amount for each ecommerce is calculated by aggregating the payment amount + flat fees + APP for each payment.

### Further Considerations

* Exceptions are thrown at runtime and handled by class ExceptionHandlerController, which is a @ControllerAdvisor. This is done to have cleaner code avoiding multiple try..catch blocks.

* There is no explicit code for thread creation/management as the embedded server (tomcat) handles that automatically, managing up to 200 concurrent requests by default (this number can be changed).

* Even though controllers and services are singletons, they have been made thread-safe by making member variables final and not keeping any state on them.

* Update of PaymentProcessors (and their associated APPs and flat fees) is handled as a @Transaction, delegating concurrency control to the underlying database.

* Unit tests have been created for the service layer, as these classes do all the heavy-lifting. Controllers just delegate their calls to the service layer and repositories use mostly the built-in operations.

### TO DO

This section lists some of the things that have been left out of this deliverable due to time constraints or that could be improved:

* Better error and exception handling.

* Using BigDecimal instead of double for more precision.

* More test coverage, possibly including application tests with @SpringBootTest

* The controller methods have been documented as an API in Swagger and the more complex methods have some regular comments to explain behaviors/features. The rest of the methods are quite simple and self-explanatory when reading them, but I would have liked to fully document them with javadoc style comments

* And more...



